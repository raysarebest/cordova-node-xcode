import { get } from "https";
import { writeFile } from "fs/promises";
import * as path from "path";

interface BuildSettingsList {
    [key: string]: BuildSettingInfo;
}

interface BuildSettingInfo {
    name?: string;
    description?: string;
    type: string;
    default_value?: unknown;
    command_line_arguments?: { [key: string]: string[] };
}

interface BuildSettingEnumerationInfo extends BuildSettingInfo {
    type: "Enumeration" | "enum" | "CodeSignStyle";
    values?: EnumerationValues;
}

type EnumerationValues = (string | {Value: string})[];

get("https://xcodebuildsettings.com/build_settings.json", (response) => {
    if(response.statusCode !== 200) {
        response.resume(); // It frees memory to consume the response whether you use it or not
        throw new Error(`The documentation server gave an unexpected response status code: ${response.statusCode}`)
    }

    response.setEncoding("utf8");

    let rawData = "";

    response.on("data", (chunk) => {
        rawData += chunk;
    });

    response.on("end", async () => {
        const settingData: BuildSettingsList = JSON.parse(rawData);

        const valueTypeModuleName = "valueTypes";

        const declarations = declarationsForSettings(settingData, valueTypeModuleName, 1);

        const fileContents =
`// This file was generated by ../../utils/updateBuildSettingTypes.ts
// Do not edit this file directly, even if some things are wonky

import * as ${valueTypeModuleName} from "./xcbuildsettingvaluetypes";

/**
 * The build settings known to Xcode and its toolchain used to configure a target's build pipeline
 */
export declare interface XcodeKnownBuildSettings {
${declarations}
}
`;

        await writeFile(path.join(__dirname, "..", "lib", "xcode-types", "knownbuildsettings.d.ts"), fileContents, "utf8");
    });
});

function declarationsForSettings(settings: BuildSettingsList, typeModuleName?: string, indendationLevel: number = 0): string {
    const indentation = "    ".repeat(indendationLevel);
    let declaration = "";

    for (const key in settings) {
        const info = settings[key];
        let commentLines: string[] = [];

        if (info.name) {
            commentLines.push(info.name);
        }

        if (info.description) {
            commentLines.push(info.description);
        }

        if (commentLines.length === 0) {
            commentLines.push("This setting is recognized, but undocumented by Xcode");
        }

        declaration += `\n${indentation}/**\n`;

        const commentLineStart = `${indentation} * `;

        commentLines.forEach((line, index, lines) => {

            for (const sanitizedLine of line.split("\n")) {
                declaration += `${commentLineStart}${sanitizedLine}\n`;
            }

            if (index !== lines.length - 1) {
                declaration += commentLineStart + "\n";
            }
        });

        declaration += `${indentation} */\n`

        declaration += `${indentation}${key}?: `;

        let compiledType: string;

        // String and string are equivalent
        // StringList and stringlist are equivalent (Space-separated list of strings, wrapping strings that contain a space in quotes, transformed into an array by cordova-node-xcode, but stays a string if empty)
        // Enumeration, enum, and CodeSignStyle are equivalent (Finite set of mutually exclusive string values)
        // Boolean, Bool, and bool are equivalent ("YES" | "NO" | string for inheritance values)
        // Path and path are likely equivalent (UNIX path as string)
        // PathList is like StringList, but with UNIX paths
        // OpenCLArchitectures is a StringList that specifies hardware architecture identifiers for which to compile OpenCL kernels
        // CodeSignIdentity is the common name of a code signing certificate in the development Mac's keychain
        // DevelopmentTeam is a string identifier of an Apple Developer team, generally found in the "Membership" section of Apple's developer account management website
        // ProvisioningProfileSpecifier is the name or UUID of a provisioning profile
        // CompilerVersion is a string denoting a semantic version or identifier for a specific edition of GCC or Clang
        // ProvisioningProfile is like ProvisioningProfileSpecifier, but only allows UUIDs and not names. This is only used for a legacy setting for very old versions of iOS that shouldn't be used in modern projects

        switch (info.type) {
            case "String":
            case "string":
                compiledType = "XcodeBuildSettingStringValue";
                break;
            case "StringList":
            case "stringlist":
                compiledType = "XcodeBuildSettingStringListValue";
                break;
            case "Enumeration":
            case "enum":
            case "CodeSignStyle":
                compiledType = "XcodeBuildSettingValue<";

                const enumInfo = info as BuildSettingEnumerationInfo;

                // Not all enumerations in Xcode documentation archive have their values set, so we need to resolve them to generate good type information
                enumInfo.values = valuesForEnumeration(key, enumInfo, settings);

                enumInfo.values.forEach((option, index, options) => {
                    compiledType += `"${typeof option === "string" ? option : option.Value}"`;

                    if (index !== options.length - 1) {
                        compiledType += ` | `;
                    }
                });

                compiledType += ">";
                break;
            case "Boolean":
            case "Bool":
            case "bool":
                compiledType = "XcodeBuildSettingBooleanValue";
                break;
            case "Path":
            case "path":
                compiledType = "XcodeBuildSettingPathValue";
                break;
            case "PathList":
                compiledType = "XcodeBuildSettingPathListValue";
                break;
            case "OpenCLArchitectures":
                compiledType = "XcodeBuildSettingOpenCLArchitecturesValue";
                break;
            case "CodeSignIdentity":
                compiledType = "XcodeBuildSettingCodeSignIdentityValue";
                break;
            case "DevelopmentTeam":
                compiledType = "XcodeBuildSettingDevelopmentTeamValue";
                break;
            case "ProvisioningProfileSpecifier":
                compiledType = "XcodeBuildSettingProvisioningProfileSpecifierValue";
                break;
            case "CompilerVersion":
                compiledType = "XcodeBuildSettingCompilerVersionValue";
                break;
            case "ProvisioningProfile":
                compiledType = "XcodeBuildSettingProvisioningProfileValue";
                break;
            default:
                throw new Error("Unknown setting type: " + info.type);
        }

        let prefix = "";

        if (typeModuleName) {
            prefix = `${typeModuleName}.`;
        }

        declaration += `${prefix}${compiledType};`
    }

    return declaration;
}

function valuesForEnumeration(key:string, enumInfo: BuildSettingEnumerationInfo, settings: BuildSettingsList): EnumerationValues {
    function fail() {
        throw new Error("Couldn't generate enumeration values for the key " + key);
    }

    if (enumInfo.values && enumInfo.values.length > 0) {
        return enumInfo.values;
    }
    // We have to special-case a few things since Xcode doesn't include values for them as of Xcode 14.0 beta 5
    else if (key === "MTL_LANGUAGE_REVISION") {
        return ["UseDeploymentTarget", "iOSMetal10", "Metal11", "Metal12", "Metal20", "Metal21", "Metal22", "Metal23", "Metal24", "Metal30"];
    }
    else if (!enumInfo.values) {
        const inheritedValueExpression = /\$\((\w+)\)/g;

        if (typeof enumInfo.default_value === "string" && inheritedValueExpression.test(enumInfo.default_value)) {
            // Some enumerations don't have values, but set their default_value to inherit from other enumerations, so we can just grab the values of those enumerations
            let values: EnumerationValues = [];
            const matchedKeys: string[] = [];

            // test in the condition advanced the lastIndex, so we need to reset it
            inheritedValueExpression.lastIndex = 0;

            let currentMatches: string[];
            while ((currentMatches = inheritedValueExpression.exec(enumInfo.default_value)) !== null) {
                matchedKeys.push(currentMatches[currentMatches.length - 1]);
            }

            for (const inheritedSettingsKey of matchedKeys) {
                const inheritedSettings = settings[inheritedSettingsKey] as BuildSettingEnumerationInfo
                values = values.concat(inheritedSettings.values && inheritedSettings.values.length > 0 ? inheritedSettings.values : valuesForEnumeration(inheritedSettingsKey, inheritedSettings, settings));

            }

            return values;
        }
        else if (enumInfo.command_line_arguments && Object.keys(enumInfo.command_line_arguments).length > 0) {
            // Other enumerations store all possible values as keys to its command line arguments
            return Object.keys(enumInfo.command_line_arguments);
        }
        else {
            fail();
        }
    }
    else {
        fail();
    }
}